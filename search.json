[{"title":"热更新原理浅析","url":"/2019/05/14/热更新原理浅析/","content":"\n<h2>热更新原理浅析</h2>\n\n<b>前言</b>\n\n热更新，说白了就是一种在不发布版本的情况下，能够让我们修复线上 Bug 的技术，现在市面上流行的热更新框架有 Tinker 、 AndFix 和 Robust。 这篇文章写出来主要是简要的分析一下热更新的原理，并且最后会介绍一下 AndFix 的用法和一些源码的分析。\n\n<b>原理</b>\n\n热更新听着很高大上，其实说穿了，就是利用 DexClassLoader 加载外部存储中的 apk/jar/dex 文件中打包生成的 davilk 虚拟机能够识别的 dex 文件，然后将他们添加到 BaseClassLoader 的 dexPathList 的前面，这样，davilk 虚拟机在加载类的时候，首先就会找到我们修复过的类，而不会加载后面的有问题的类， 从而达成了修复 Bug 的目的。\n\n<b>实现</b>\n\n上一下核心代码\n\n```\npublic class HotFixUtil {\n\n    private static final String TAG = \"lxbnjupt\";\n    private static final String NAME_BASE_DEX_CLASS_LOADER = \"dalvik.system.BaseDexClassLoader\";\n    private static final String FIELD_DEX_ELEMENTS = \"dexElements\";\n    private static final String FIELD_PATH_LIST = \"pathList\";\n    private static final String DEX_SUFFIX = \".dex\";\n    private static final String APK_SUFFIX = \".apk\";\n    private static final String JAR_SUFFIX = \".jar\";\n    private static final String ZIP_SUFFIX = \".zip\";\n    private static final String DEX_DIR = \"patch\";\n    private static final String OPTIMIZE_DEX_DIR = \"odex\";\n\n    public static void doHotFix(Context context) throws IllegalAccessException, NoSuchFieldException, ClassNotFoundException {\n        if (context == null) {\n            return;\n        }\n        // 补丁存放目录为 /storage/emulated/0/Android/data/com.lxbnjupt.hotfixdemo/files/patch\n        File dexFile = HotFixManager.getPatchDexFile();\n        if (dexFile == null || !dexFile.exists()) {\n            Log.e(TAG, \"热更新补丁目录不存在\");\n            return;\n        }\n        File odexFile = context.getDir(OPTIMIZE_DEX_DIR, Context.MODE_PRIVATE);\n        if (!odexFile.exists()) {\n            odexFile.mkdir();\n        }\n        File[] listFiles = null;\n        if (dexFile.isFile()) {\n            listFiles = new File[]{dexFile};\n        } else {\n            listFiles = dexFile.listFiles();\n        }\n        if (listFiles == null || listFiles.length == 0) {\n            return;\n        }\n        String dexPath = getPatchDexPath(listFiles);\n        String odexPath = odexFile.getAbsolutePath();\n        // 获取PathClassLoader\n        PathClassLoader pathClassLoader = (PathClassLoader) context.getClassLoader();\n        // 构建DexClassLoader，用于加载补丁dex\n        DexClassLoader dexClassLoader = new DexClassLoader(dexPath, odexPath, null, pathClassLoader);\n        // 获取PathClassLoader的Element数组\n        Object pathElements = getDexElements(pathClassLoader);\n        // 获取构建的DexClassLoader的Element数组\n        Object dexElements = getDexElements(dexClassLoader);\n        // 合并Element数组\n        Object combineElementArray = combineElementArray(pathElements, dexElements);\n        // 通过反射，将合并后的Element数组赋值给PathClassLoader中pathList里面的dexElements变量\n        setDexElements(pathClassLoader, combineElementArray);\n    }\n\n    /**\n     * 获取补丁dex文件路径集合\n     *\n     * @param listFiles\n     * @return\n     */\n    private static String getPatchDexPath(File[] listFiles) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < listFiles.length; i++) {\n            // 遍历查找文件中.dex .jar .apk .zip结尾的文件\n            File file = listFiles[i];\n            if (file.getName().endsWith(DEX_SUFFIX)\n                    || file.getName().endsWith(APK_SUFFIX)\n                    || file.getName().endsWith(JAR_SUFFIX)\n                    || file.getName().endsWith(ZIP_SUFFIX)) {\n                if (i != 0 && i != (listFiles.length - 1)) {\n                    // 多个dex路径 添加默认的:分隔符\n                    sb.append(File.pathSeparator);\n                }\n                sb.append(file.getAbsolutePath());\n            }\n        }\n        return sb.toString();\n    }\n\n    /**\n     * 合并Element数组，将补丁dex放在最前面\n     *\n     * @param pathElements PathClassLoader中pathList里面的Element数组\n     * @param dexElements  补丁dex数组\n     * @return 合并之后的Element数组\n     */\n    private static Object combineElementArray(Object pathElements, Object dexElements) {\n        Class<?> componentType = pathElements.getClass().getComponentType();\n        int i = Array.getLength(pathElements);// 原dex数组长度\n        int j = Array.getLength(dexElements);// 补丁dex数组长度\n        int k = i + j;// 总数组长度（原dex数组长度 + 补丁dex数组长度)\n        Object result = Array.newInstance(componentType, k);// 创建一个类型为componentType，长度为k的新数组\n        System.arraycopy(dexElements, 0, result, 0, j);// 补丁dex数组在前\n        System.arraycopy(pathElements, 0, result, j, i);// 原dex数组在后\n        return result;\n    }\n\n    /**\n     * 获取Element数组\n     *\n     * @param classLoader 类加载器\n     * @return\n     * @throws ClassNotFoundException\n     * @throws NoSuchFieldException\n     * @throws IllegalAccessException\n     */\n    private static Object getDexElements(ClassLoader classLoader) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException {\n        // 获取BaseDexClassLoader，是PathClassLoader以及DexClassLoader的父类\n        Class<?> BaseDexClassLoaderClazz = Class.forName(NAME_BASE_DEX_CLASS_LOADER);\n        // 获取pathList字段，并设置为可以访问\n        Field pathListField = BaseDexClassLoaderClazz.getDeclaredField(FIELD_PATH_LIST);\n        pathListField.setAccessible(true);\n        // 获取DexPathList对象\n        Object dexPathList = pathListField.get(classLoader);\n        // 获取dexElements字段，并设置为可以访问\n        Field dexElementsField = dexPathList.getClass().getDeclaredField(FIELD_DEX_ELEMENTS);\n        dexElementsField.setAccessible(true);\n        // 获取Element数组，并返回\n        return dexElementsField.get(dexPathList);\n    }\n\n    /**\n     * 通过反射，将合并后的Element数组赋值给PathClassLoader中pathList里面的dexElements变量\n     *\n     * @param classLoader PathClassLoader类加载器\n     * @param value       合并后的Element数组\n     * @throws ClassNotFoundException\n     * @throws NoSuchFieldException\n     * @throws IllegalAccessException\n     */\n    private static void setDexElements(ClassLoader classLoader, Object value) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException {\n        // 获取BaseDexClassLoader，是PathClassLoader以及DexClassLoader的父类\n        Class<?> BaseDexClassLoaderClazz = Class.forName(NAME_BASE_DEX_CLASS_LOADER);\n        // 获取pathList字段，并设置为可以访问\n        Field pathListField = BaseDexClassLoaderClazz.getDeclaredField(FIELD_PATH_LIST);\n        pathListField.setAccessible(true);\n        // 获取DexPathList对象\n        Object dexPathList = pathListField.get(classLoader);\n        // 获取dexElements字段，并设置为可以访问\n        Field dexElementsField = dexPathList.getClass().getDeclaredField(FIELD_DEX_ELEMENTS);\n        dexElementsField.setAccessible(true);\n        // 将合并后的Element数组赋值给dexElements变量\n        dexElementsField.set(dexPathList, value);\n    }\n}\n\n\n```\n\n该有的注释代码里都有体现，使用时调用 doHotFix 方法就可以了， 补丁文件事先通过网络进行下载， 然后存放在 /storage/emulated/0/Android/data/com.lxbnjupt.hotfixdemo/files/patch 目录下，我这里使用的补丁文件是通过 build-tools 下的 dx 工具打包成的 dex。 具体的使用命令如下\n\n```\n\ndx --dex -output=outPath 修复的文件路径 ...\n\n\n```\n\n想要源代码的朋友戳这里： [HotFix](https://github.com/LakeMirror/hotfix-android)\n\n<b>AndFix</b>\n\n关于 AndFix 使用，可以去 gitHub 下查看一下它的 index.md ，基本上说的已经非常详细了： [AndFix](https://github.com/alibaba/AndFix)\n\n这里主要分析一下它的实现：\n\n>首先是 pacthManager = new PatchManager(this);\n\n```\npublic PatchManager(Context context) {\n\t\tmContext = context;\n\t\tmAndFixManager = new AndFixManager(mContext);\n\t\tmPatchDir = new File(mContext.getFilesDir(), DIR);\n\t\tmPatchs = new ConcurrentSkipListSet<Patch>();\n\t\tmLoaders = new ConcurrentHashMap<String, ClassLoader>();\n}\n\n```\n\n其中最重要的应该是\n\n```\nmAndFixManager = new AndFixManager(mContext);\nmPatchDir = new File(mContext.getFilesDir(), DIR);\n\n```\n\n首先看一下 AndFixManger\n\n```\n\npublic AndFixManager(Context context) {\n\t\tmContext = context;\n\t\t// whether support on the device\n\t\tmSupport = Compat.isSupport();\n\t\tif (mSupport) {\n\t\t\tmSecurityChecker = new SecurityChecker(mContext);\n\t\t\tmOptDir = new File(mContext.getFilesDir(), DIR);\n\t\t\tif (!mOptDir.exists() && !mOptDir.mkdirs()) {// make directory fail\n\t\t\t\tmSupport = false;\n\t\t\t\tLog.e(TAG, \"opt dir create error.\");\n\t\t\t} else if (!mOptDir.isDirectory()) {// not directory\n\t\t\t\tmOptDir.delete();\n\t\t\t\tmSupport = false;\n\t\t\t}\n\t\t}\n\t}\n\n```\n\nAndFixManger 的构造方法中， Compat.isSupport() 做了一些是否支持的判断，主要有是否为 yunOs 系统， java 虚拟机版本号还有 android 的 SDK 版本等。 SecurityChecker 主要是做是否签名信息的获取。\n\n然后 mPatchDir 是 AndFix 默认的 apatch 文件存放的位置，不调用 addPatch() 方法的情况下， loadPatch() 会去此目录下查找 apatch 文件；\n\n> patchManager.init(versionName);\n\n```\npublic void init(String appVersion) {\n\t\tif (!mPatchDir.exists() && !mPatchDir.mkdirs()) {// make directory fail\n\t\t\tLog.e(TAG, \"patch dir create error.\");\n\t\t\treturn;\n\t\t} else if (!mPatchDir.isDirectory()) {// not directory\n\t\t\tmPatchDir.delete();\n\t\t\treturn;\n\t\t}\n\t\tSharedPreferences sp = mContext.getSharedPreferences(SP_NAME,\n\t\t\t\tContext.MODE_PRIVATE);\n\t\tString ver = sp.getString(SP_VERSION, null);\n\t\tif (ver == null || !ver.equalsIgnoreCase(appVersion)) {\n\t\t\tcleanPatch();\n\t\t\tsp.edit().putString(SP_VERSION, appVersion).commit();\n\t\t} else {\n\t\t\tinitPatchs();\n\t\t}\n\t}\n\n```\n\n这段代码主要是判断 SharedPreferences 中保存的 SP_VERSION 是否与传入的 appVersion 一致， 如果一致的的话， 直接调用 initPatchs() 将默认目录下的 apatch 文件加载进来， 如果不一致，将 apatch 目录清空以方便加载新的 apatch 文件。\n\n```\nprivate void cleanPatch() {\n\t\tFile[] files = mPatchDir.listFiles();\n\t\tfor (File file : files) {\n\t\t\tmAndFixManager.removeOptFile(file);\n\t\t\tif (!FileUtil.deleteFile(file)) {\n\t\t\t\tLog.e(TAG, file.getName() + \" delete error.\");\n\t\t\t}\n\t\t}\n\t}\n\n\nprivate void initPatchs() {\n\t\tFile[] files = mPatchDir.listFiles();\n\t\tfor (File file : files) {\n\t\t\taddPatch(file);\n\t\t}\n\t}\n\nprivate Patch addPatch(File file) {\n\t\tPatch patch = null;\n\t\tif (file.getName().endsWith(SUFFIX)) {\n\t\t\ttry {\n\t\t\t\tpatch = new Patch(file);\n\t\t\t\tmPatchs.add(patch);\n\t\t\t} catch (IOException e) {\n\t\t\t\tLog.e(TAG, \"addPatch\", e);\n\t\t\t}\n\t\t}\n\t\treturn patch;\n\t}\n\n```\n\n> loadPatch() 方法\n\n```\n\npublic void loadPatch() {\n\t\tmLoaders.put(\"*\", mContext.getClassLoader());// wildcard\n\t\tSet<String> patchNames;\n\t\tList<String> classes;\n\t\tfor (Patch patch : mPatchs) {\n\t\t\tpatchNames = patch.getPatchNames();\n\t\t\tfor (String patchName : patchNames) {\n\t\t\t\tclasses = patch.getClasses(patchName);\n\t\t\t\tmAndFixManager.fix(patch.getFile(), mContext.getClassLoader(),\n\t\t\t\t\t\tclasses);\n\t\t\t}\n\t\t}\n\t}\n\n```\n\n重点很清晰了 AndFixManager 的 fix 方法，下面看一代码\n\n```\npublic synchronized void fix(File file, ClassLoader classLoader,\n\t\t\tList<String> classes) {\n\t\t// 判断是否支持\n\t\tif (!mSupport) {\n\t\t\treturn;\n\t\t}\n\t\t// 判断签名是否一致\n\t\tif (!mSecurityChecker.verifyApk(file)) {// security check fail\n\t\t\treturn;\n\t\t}\n\t\t\n\t\ttry {\n\t\t\tFile optfile = new File(mOptDir, file.getName());\n\t\t\tboolean saveFingerprint = true;\n\t\t\tif (optfile.exists()) {\n\t\t\t\t// need to verify fingerprint when the optimize file exist,\n\t\t\t\t// prevent someone attack on jailbreak device with\n\t\t\t\t// Vulnerability-Parasyte.\n\t\t\t\t// btw:exaggerated android Vulnerability-Parasyte\n\t\t\t\t// http://secauo.com/Exaggerated-Android-Vulnerability-Parasyte.html\n\t\t\t\tif (mSecurityChecker.verifyOpt(optfile)) {\n\t\t\t\t\tsaveFingerprint = false;\n\t\t\t\t} else if (!optfile.delete()) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfinal DexFile dexFile = DexFile.loadDex(file.getAbsolutePath(),\n\t\t\t\t\toptfile.getAbsolutePath(), Context.MODE_PRIVATE);\n\n\t\t\tif (saveFingerprint) {\n\t\t\t\tmSecurityChecker.saveOptSig(optfile);\n\t\t\t}\n\n\t\t\tClassLoader patchClassLoader = new ClassLoader(classLoader) {\n\t\t\t\t@Override\n\t\t\t\tprotected Class<?> findClass(String className)\n\t\t\t\t\t\tthrows ClassNotFoundException {\n\t\t\t\t\tClass<?> clazz = dexFile.loadClass(className, this);\n\t\t\t\t\tif (clazz == null\n\t\t\t\t\t\t\t&& className.startsWith(\"com.alipay.euler.andfix\")) {\n\t\t\t\t\t\treturn Class.forName(className);// annotation’s class\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// not found\n\t\t\t\t\t}\n\t\t\t\t\tif (clazz == null) {\n\t\t\t\t\t\tthrow new ClassNotFoundException(className);\n\t\t\t\t\t}\n\t\t\t\t\treturn clazz;\n\t\t\t\t}\n\t\t\t};\n\t\t\tEnumeration<String> entrys = dexFile.entries();\n\t\t\tClass<?> clazz = null;\n\t\t\twhile (entrys.hasMoreElements()) {\n\t\t\t\tString entry = entrys.nextElement();\n\t\t\t\tif (classes != null && !classes.contains(entry)) {\n\t\t\t\t\tcontinue;// skip, not need fix\n\t\t\t\t}\n\t\t\t\tclazz = dexFile.loadClass(entry, patchClassLoader);\n\t\t\t\tif (clazz != null) {\n\t\t\t\t\tfixClass(clazz, classLoader);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tLog.e(TAG, \"pacth\", e);\n\t\t}\n\t}\n\n```\n\n经过一系列的判断后，最终拿到符合要求的 clazz 文件， 调用 fixClass() 方法进行修复。\n\n```\n\nprivate void fixClass(Class<?> clazz, ClassLoader classLoader) {\n\t\tMethod[] methods = clazz.getDeclaredMethods();\n\t\tMethodReplace methodReplace;\n\t\tString clz;\n\t\tString meth;\n\t\tfor (Method method : methods) {\n\t\t\tmethodReplace = method.getAnnotation(MethodReplace.class);\n\t\t\tif (methodReplace == null)\n\t\t\t\tcontinue;\n\t\t\tclz = methodReplace.clazz();\n\t\t\tmeth = methodReplace.method();\n\t\t\tif (!isEmpty(clz) && !isEmpty(meth)) {\n\t\t\t\treplaceMethod(classLoader, clz, meth, method);\n\t\t\t}\n\t\t}\n\t}\n\n```\n\n这个方法已经很明确了，就是遍历所有方法后，将有 MethodReplace 注解的方法（就是需要修复的方法）替换掉， 至于 replaceMethod 中更深层次的实现， 大家有兴趣的可以自己去研究。\n\n\n<b>总结</b>\n\n热修复之前总是在听说，一直觉得不懂但是很厉害的样子，现在接触下来，发现其实只要懂了一些后，并不是那么的不可亵玩，万事都是开头难而已。\n\n欢迎有疑问的朋友留言讨论。\n\n\n\n\n","tags":["Android","HotFix"]},{"title":"Android 插件化浅析","url":"/2019/05/13/Android-插件化浅析/","content":"\n<h2>Android 插件化浅析</h2>\n\n<b>前言： 组件化和插件化</b>\n> 组件化\n\n组件化就是将 App 拆分成几个低耦合的组件，每个组件负责不同的功能， 独立进行编译。 其好处是使并行开发变得简单(版本管理，互相不耦合等)， 且组件独立编译， 可以提高编译的效率。\n\n> 插件化\n\n如果说组件化就是划分为不同的 Module 的话， 插件化就是划分成不同的 apk， 使用插件时， 将 apk 中的打包的 dex 文件添加到主程序的的 Dex 文件集合中，这样就可以调用其中的类与方法。\n\n组件化与插件化的相同点在于都是将一个完整庞杂的 App， 根据不同的要求划分成了一些不同的部分，提升了开发的效率，并且提高了代码的可维护性。\n\n不同点在于，组件化的使用是静态加载的，你能使用什么组件，在你最初打包 apk 的时候就已经定下来了，但是插件化不同，你可以在你需要使用的时候，下载对应的插件，然后动态的加载到应用中使用。\n\n<b> 基本原理 </b>\n\n> 类的加载\n\n\nAndroid中常用的有两种类加载器，DexClassLoader 和 PathClassLoader，它们都继承于BaseDexClassLoader\n\n```\n\n// DexClassLoader\npublic class DexClassLoader extends BaseDexClassLoader {    \n\tpublic DexClassLoader(String dexPath, String optimizedDirectory,\n            String libraryPath, ClassLoader parent) {        \n\t\tsuper(dexPath, new File(optimizedDirectory), libraryPath, parent);\n    }\n}\n\n// PathClassLoader\npublic class PathClassLoader extends BaseDexClassLoader {    \n\n\tpublic PathClassLoader(String dexPath, ClassLoader parent) {     \n   \t\tsuper(dexPath, null, null, parent);\n    } \n    \n \tpublic PathClassLoader(String dexPath, String libraryPath,\n            ClassLoader parent) {    \n    \tsuper(dexPath, null, libraryPath, parent);\n    }\n}\n```\n\n区别在于调用父类构造器时，DexClassLoader多传了一个optimizedDirectory参数，这个目录必须是内部存储路径，用来缓存系统创建的Dex文件。而PathClassLoader该参数为null，只能加载内部存储目录的Dex文件。\n\n所以我们可以用DexClassLoader去加载外部的apk，用法如下\n\n```\n\n\tnew DexClassLoader(apk.getAbsolutePath(), dexOutputPath, libsDir.getAbsolutePath(), parent)\n\n\n```\n\n> 资源加载\n\nAndroid系统通过Resource对象加载资源，下面代码展示了该对象的生成过程\n\n```\n\n//创建AssetManager对象 \nAssetManager assets = new AssetManager();\n //将apk路径添加到AssetManager中\n  if (assets.addAssetPath(resDir) == 0){              \n    return null;  \n}\n //创建Resource对象\n\nr = new Resources(assets, metrics, getConfiguration(), compInfo);\n\n```\n\n如果要使用 apk 插件中的资源， 则需要将 apk 的路径加入到 AssetManager 中， 最后将 assetManager 生成的 Resource 类通过反射设置到上下文的 mResource 字段中即可。\n\n\n> 四大组件之 Activity 的加载\n\n插件化中 Activity 的使用可以通过两种方式来实现， 一种是 Proxy 代理类， 还有一种是 hook， 而后一种是现在实现的主要方式。 而 Hook 方式的实现目前主要是采用占坑实现，及事先在 Manifest 中注册一个用来占坑的 Activity, 再启动插件 Activity 的时候，首先将之替换为占坑的 Activity 以通过 AMS 的检测， 然后在 ActivityThread 真正启动 Activity 之前将插件的 Activity 替换回来。\n\n要理解 hook 的实现， 首先要了解一下 Activity 的启动流程， 附上一篇文章供参考: [Activity启动](https://www.jianshu.com/p/a626387cd523)\n\n大致了解之后， 发现 IActivityManager 是一个很好的 hook 点, 我们只需要拦截它的 startActivity 方法，将要启动的 Activity 替换为占坑 Activity, 这样可以顺利的通过 AMS 的检测。\n\n```\n\npublic class IActivityManagerProxy implements InvocationHandler {\n    private Object mActivityManager;\n    private static final String TAG = \"IActivityManagerProxy\";\n\n    public IActivityManagerProxy(Object activityManager) {\n        this.mActivityManager = activityManager;\n    }\n\n    @Override\n    public Object invoke(Object o, Method method, Object[] args) throws Throwable {\n        //1\n        if (\"startActivity\".equals(method.getName())) {\n            Intent intent = null;\n            int index = 0;\n            for (int i = 0; i < args.length; i++) {\n                if (args[i] instanceof Intent) {\n                    index = i;\n                    break;\n                }\n            }\n            intent = (Intent) args[index];\n            //2\n            Intent subIntent = new Intent();\n            String packageName = \"主程序包名\";\n            //3 替换为占坑的 Activity\n            subIntent.setClassName(packageName, packageName + \".StubActivity\");\n            // 4 保存真正要跳转的 Intent 恢复时使用\n            subIntent.putExtra(HookHelper.TARGET_INTENT, intent);\n            //5\n            args[index] = subIntent;\n        }\n        return method.invoke(mActivityManager, args);\n    }\n}\n\n\n```\n\n然后在自定义的 application 中调用如下方法即可\n\n```\n public static void hookAMS() throws Exception {\n        Object defaultSingleton = null;\n        //1\n        if (Build.VERSION.SDK_INT >= 26) {\n            Class<?> activityManageClazz = Class.forName(\"android.app.ActivityManager\");\n            //获取activityManager中的IActivityManagerSingleton字段\n            defaultSingleton = FieldUtil.getField(activityManageClazz, null, \"IActivityManagerSingleton\");\n        } else {\n            Class<?> activityManagerNativeClazz = Class.forName(\"android.app.ActivityManagerNative\");\n            //获取ActivityManagerNative中的gDefault字段\n            defaultSingleton = FieldUtil.getField(activityManagerNativeClazz, null, \"gDefault\");\n        }\n        Class<?> singletonClazz = Class.forName(\"android.util.Singleton\");\n        //2\n        Field mInstanceField = FieldUtil.getField(singletonClazz, \"mInstance\");\n        //获取iActivityManager //3\n        Object iActivityManager = mInstanceField.get(defaultSingleton);\n        Class<?> iActivityManagerClazz = Class.forName(\"android.app.IActivityManager\");\n        Object proxy = Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),\n                new Class<?>[]{iActivityManagerClazz}, new IActivityManagerProxy(iActivityManager));\n        mInstanceField.set(defaultSingleton, proxy);\n    }\n\n```\n\n做到这里，我们才做完了一半， 接下来就是在启动之前将 intent 换为我们原本要启动的 Activity 的 intent, 这个 hook 点我们可以选择 ActivityThread 的内部类 H(集成自Handler), 通过自定义 \n\n```\npublic class HCallback implements android.os.Handler.Callback {\n    public static final int LAUNCH_ACTIVITY = 100;\n    Handler mHandler;\n\n    public HCallback(Handler handler) {\n        mHandler = handler;\n    }\n\n    @Override\n    public boolean handleMessage(Message msg) {\n        if (msg.what == LAUNCH_ACTIVITY) {\n            Object r = msg.obj;\n            try {\n                //得到消息中的Intent(启动SubActivity的Intent)\n                Intent intent = (Intent) FieldUtil.getField(r.getClass(), r, \"intent\");\n                //得到此前保存起来的Intent(启动TargetActivity的Intent)\n                Intent target = intent.getParcelableExtra(HookHelper.TARGET_INTENT);\n                //将启动SubActivity的Intent替换为启动TargetActivity的Intent\n                intent.setComponent(target.getComponent());\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        mHandler.handleMessage(msg);\n        return true;\n    }\n}\n\n```\n\n然后替换掉 ActivityThread 中的字段\n\n```\n\npublic static void hookHandler() throws Exception {\n        Class<?> activityThreadClass = Class.forName(\"android.app.ActivityThread\");\n        //1\n        Object currentActivityThread= FieldUtil.getField(activityThreadClass ,null,\"sCurrentActivityThread\");\n        //2\n        Field mHField = FieldUtil.getField(activityThreadClass,\"mH\");\n        //3\n        Handler mH = (Handler) mHField.get(currentActivityThread);\n        FieldUtil.setField(Handler.class,mH,\"mCallback\",new HCallback(mH));\n    }\n\n```\n\n> 代码实现\n\n```\n/**\n* 加载插件 Apk\n*/\npublic void loadPluginApk() {\n        try {\n            File dst = new File(getDir(\"dex\", Context.MODE_PRIVATE).getAbsolutePath());\n\t\t\t// 因为不是下载的 apk 原本放在 assets 目录下， 先复制到内存卡中\n            FileUtils.copyAssetsFile(this, \"plugin.apk\", dst);\n            // DexClassLoader\n            String dexPath = getFileStreamPath(\"plugin.apk\").getAbsolutePath();\n            String fileReleasePath = getDir(\"dex\", Context.MODE_PRIVATE).getAbsolutePath();\n            dexPluginLoader = new DexClassLoader(dexPath, fileReleasePath, null, getClassLoader());\n            // AssetManager\n            replaceClassLoader(dexPluginLoader);\n            Class assetClass = AssetManager.class;\n            mAssetManager = (AssetManager) assetClass.newInstance();\n            Method addAssetPath = mAssetManager.getClass().getMethod(\"addAssetPath\",\n                    String.class);\n            addAssetPath.invoke(mAssetManager, getFilesDir().getAbsolutePath() + File.separator + \"plugin.apk\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n/**\n* 将加载过插件 apk 的 DexClassLoader 合并到原本的 DexClassLoader 中\n*/\nprivate void replaceClassLoader(DexClassLoader loader) {\n        try {\n            Class clazz_Ath = Class.forName(\"android.app.ActivityThread\");\n            Class clazz_LApk = Class.forName(\"android.app.LoadedApk\");\n            Object currentActivityThread = clazz_Ath.getMethod(\"currentActivityThread\").invoke(null);\n            Field field1 = clazz_Ath.getDeclaredField(\"mPackages\");\n            field1.setAccessible(true);\n            Map mPackages = (Map) field1.get(currentActivityThread);\n            String packageName = getPackageName();\n            WeakReference ref = (WeakReference) mPackages.get(packageName);\n            Field field2 = clazz_LApk.getDeclaredField(\"mClassLoader\");\n            field2.setAccessible(true);\n            field2.set(ref.get(), loader);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n/**\n* 获取插件的资源\n*/\npublic void replaceContextResources(Context context, Resources resources){\n        try {\n            Field field = context.getClass().getDeclaredField(\"mResources\");\n            field.setAccessible(true);\n            field.set(context, resources);\n            System.out.println(\"debug:repalceResources succ\");\n        } catch (Exception e) {\n            System.out.println(\"debug:repalceResources error\");\n            e.printStackTrace();\n        }\n    }\n\n\t@Override\n    public void onCreate() {\n        super.onCreate();\n        loadPluginApk();\n        try {\n            HookHelper.hookAMS();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        Resources resources = new Resources(mAssetManager, getResources().getDisplayMetrics(), getResources().getConfiguration());\n        replaceContextResources(this, resources);\n    }\n\n    @Override\n    protected void attachBaseContext(Context base) {\n        super.attachBaseContext(base);\n        try {\n            HookHelper.hookHandler();\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n\n/**\n* 调用 kotlin 代码\n*/\n\noverride fun onClick(v: View?) {\n        when (v?.id) {\n            R.id.bt_test_method -> {\n                // 使用插件中的类\n                var stringUtils: Class<*> = MyApplication.dexPluginLoader.loadClass(\"learn.hugy.com.pluginapk.StringUtils\")\n                var equalsMethod: Method = stringUtils.getDeclaredMethod(\"equals\", String::class.java, String::class.java)\n                Toast.makeText(this, equalsMethod.invoke(null, \"1\", \"2\").toString(), Toast.LENGTH_SHORT).show()\n            }\n            R.id.bt_test_resource -> {\n                val pluginResource = Resources(MyApplication.mAssetManager, resources.displayMetrics, resources.configuration)\n                val resId = getResId(this, filesDir.absolutePath + File.separator + \"plugin.apk\", \"learn.hugy.com.pluginapk\", \"warning\")\n                var drawable: Drawable = pluginResource.getDrawable(resId)\n                val inputStream: InputStream = pluginResource.assets.open(\"hello.html\")\n                val bts = ByteArray(1024)\n                var len = inputStream.read(bts)\n                while (len != -1) {\n                    Log.i(\"PLUGIN\", String(bts))\n                    len = inputStream.read(bts)\n                }\n\n            }\n            R.id.bt_test_activity -> {\n                // 使用插件中的类\n                var pluginActivity: Class<*> = MyApplication.dexPluginLoader.loadClass(\"learn.hugy.com.pluginapk.PluginActivity\")\n                var intent = Intent(this, pluginActivity)\n                startActivity(intent)\n            }\n        }\n    }\n```\n\n<b>总结</b>\n\n插件化的实现分为类的加载，资源的使用和四大组件的加载，其中四大组件的加载是重点，本文主要讲述了 hook IActivityManager 来实现 Activity 的使用。\n\n如有什么疑问，欢迎留言讨论。","tags":["Android","插件化"]},{"title":"消息推送之Socket实现","url":"/2019/05/13/消息推送之Socket实现/","content":"<h2>消息推送之 Socket 实现</h2>\n\n>前言\n\n 现在市面上流行了很多消息推送框架，如极光， 这些消息推送框架无不是需要外网才能实现推送，但是不巧的是， 公司开发的 App 必须要在内网的条件下使用。 所以，通过网上搜索资料， 自己完成了一个基于 Socket 实现的 Android 端的消息推送模块，写下这篇博文以作记录。\n\n> 实现思路\n\n 说到推送，其实现方式无非就是 2 种， 轮询（就是每隔固定的时间向后台发送请求去查看有没有新的消息）还有长链接， 其他的还有什么长轮询啊，WebSocket 什么的，个人认为也是脱胎于这两种方式的。\n\n 轮询，实现起来简单，就是通过线程池写一个定时循环执行的任务，不断的向后台去请求，如果有新的消息就返回，没有就过一段时间进行下一次请求。 这种方式缺点很明显，需要不断的去发送请求，而且，并不具有实时性，新消息建立之后必须要等到下一次轮询发出后才能让前台拿到。\n\n 长链接，实现起来想对复杂，不过它不用发送那么多的无用请求，且消息也能够及时的传递到客户端，其唯一的缺点就是服务器端需要针对每一个连接的客户端维护一个长链接，增加了服务器的开销。\n\n 这篇博文主要是通过长链接的方式实现的， 而实现长链接的方式是 Socket。\n\n> Socket\n\n Socket 套接字，它并不是一种协议, 而是对 TCP/UDP 协议的一种封装，使我们能够更加方便的调用 TCP/UDP 协议的一些接口。\n\n> 具体实现\n\n\n>> Android\n\n由于长链接需要在 APP 启动过程中一直存在，所以启动一个 Service 来建立长链接是一个非常好的实现方式\n\n```android\n\npublic class ConnectService extends Service {\n\t\n\t private static final String TAG = \"BackService\";\n    //心跳包频率\n    private static final long HEART_BEAT_RATE = 30 * 1000;\n\n    public static final String HOST = \"服务器IP\";\n    public static final int PORT = \"ServerSocket 开放端口\";\n\n    public static final String MESSAGE_ACTION = \"cn.win.notification.push\";\n    public static final String HEART_BEAT_ACTION = \"com.splxtech.powermanagor.engine.socket.heart\";\n    //心跳包内容\n    public static final String HEART_BEAT_STRING = \"00\";\n\n    private ReadThread mReadThread;\n\n    private LocalBroadcastManager mLocalBroadcastManager;\n\n    private WeakReference<Socket> mSocket;\n\n    // For heart Beat\n    private Handler mHandler = new Handler();\n    private Runnable heartBeatRunnable = new Runnable() {\n\n        @Override\n        public void run() {\n            if (System.currentTimeMillis() - sendTime >= HEART_BEAT_RATE) {\n                //就发送一个HEART_BEAT_STRING过去 如果发送失败，就重新初始化一个socket\n                boolean isSuccess = sendMsg(HEART_BEAT_STRING);\n                if (!isSuccess) {\n                    mHandler.removeCallbacks(heartBeatRunnable);\n                    mReadThread.release();\n                    releaseLastSocket(mSocket);\n                    new InitSocketThread().start();\n                }\n            }\n            mHandler.postDelayed(this, HEART_BEAT_RATE);\n        }\n    };\n\n    private long sendTime = 0L;\n    private String uid;\n\n    private ExecutorService executor = Executors.newFixedThreadPool(3);\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        new InitSocketThread().start();\n        mLocalBroadcastManager = LocalBroadcastManager.getInstance(this);\n\n    }\n\n    @Override\n    public IBinder onBind(Intent intent) {\n        return null;\n    }\n\n    public boolean sendMsg(final String msg) {\n        if (null == mSocket || null == mSocket.get()) {\n            return false;\n        }\n        final Socket soc = mSocket.get();\n\n        if (!soc.isClosed() && !soc.isOutputShutdown()) {\n            executor.execute(new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        OutputStream os = soc.getOutputStream();\n                        String message = msg;\n                        os.write(message.getBytes());\n                        os.flush();\n                        //每次发送成数据，就改一下最后成功发送的时间，节省心跳间隔时间\n                        sendTime = System.currentTimeMillis();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            });\n        } else {\n            return false;\n        }\n\n        return true;\n    }\n\n    private void initSocket() {//初始化Socket\n        try {\n            Socket so = new Socket(HOST, PORT);\n            // 像服务端表明身份\n            OutputStream os = so.getOutputStream();\n            //we make this look like a valid IMEI\n            uid = PushSocket.getIdBean();\n            os.write(uid.getBytes());\n            os.flush();\n            mSocket = new WeakReference<Socket>(so);\n            mReadThread = new ReadThread(so);\n            mReadThread.start();\n            //初始化成功后，就准备发送心跳包\n            mHandler.postDelayed(heartBeatRunnable, HEART_BEAT_RATE);\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void releaseLastSocket(WeakReference<Socket> mSocket) {\n        try {\n            if (null != mSocket) {\n                Socket sk = mSocket.get();\n                if (!sk.isClosed()) {\n                    sk.close();\n                }\n                sk = null;\n                mSocket = null;\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    class InitSocketThread extends Thread {\n        @Override\n        public void run() {\n            super.run();\n            initSocket();\n        }\n    }\n\n    // Thread to read content from Socket\n    class ReadThread extends Thread {\n        private WeakReference<Socket> mWeakSocket;\n        private boolean isStart = true;\n\n        public ReadThread(Socket socket) {\n            mWeakSocket = new WeakReference<Socket>(socket);\n        }\n\n        public void release() {\n            isStart = false;\n            releaseLastSocket(mWeakSocket);\n        }\n\n        @Override\n        public void run() {\n            super.run();\n            Socket socket = mWeakSocket.get();\n            if (null != socket) {\n                try {\n                    InputStream is = socket.getInputStream();\n                    byte[] buffer = new byte[1024 * 4];\n                    int length = 0;\n                    while (!socket.isClosed() && !socket.isInputShutdown()\n                            && isStart && ((length = is.read(buffer)) != -1)) {\n                        if (length > 0) {\n                            String message = new String(Arrays.copyOf(buffer,\n                                    length)).trim();\n                            Log.e(TAG, message);\n                            //收到服务器过来的消息，就通过Broadcast发送出去\n                            //处理心跳回复\n                            if (message.equals(HEART_BEAT_STRING)) {\n                                Intent intent = new Intent(HEART_BEAT_ACTION);\n                                mLocalBroadcastManager.sendBroadcast(intent);\n                            } else {\n                                //其他消息回复\n                                Intent intent = new Intent(MESSAGE_ACTION);\n                                intent.putExtra(\"msg\", message);\n                                sendBroadcast(intent);\n                            }\n                        }\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    @Override\n    public void onDestroy() {\n        super.onDestroy();\n        // 通知后台此 socket 已离线\n        Log.i(\"Hugy\", \"onDestroy\");\n        executor.execute(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    URL url = new URL(服务器地址 + \"/test/offline/\" + uid);\n                    HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n                    connection.setConnectTimeout(10000);\n                    connection.setRequestMethod(\"GET\");\n                    connection.connect();\n                } catch (MalformedURLException e) {\n                    e.printStackTrace();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        });\n    }\n\n\n}\n\n```\n\n在 Service 启动的时候（onCreate），初始化 Socket 与服务端建立一个连接，并启动一个线程读取服务端推送的消息。\n\n这里有几点需要注意：\n\n1、 第一次连接的时候，可以向后台发送一个身份标识，我这里包含了一个用户的唯一标识（与手机绑定, 避免后台保存多个同一用户的 Socket）, 还有用户的分组(推送的时候进行分组推送用), 电话等信息\n\n```\n\npublic class IdBean {\n    /**\n     * 唯一身份标识\n     */\n    private String idNum;\n    /**\n     * 用户分组，如有权限控制，应该根据权限来\n     */\n    private String group;\n    /**\n     * 用户账户\n     */\n    private String userAccount;\n    /**\n     * 用户手机号\n     */\n    private String phone;\n\n    public IdBean() {\n    }\n\n    public IdBean(String idNum, String group, String userAccount, String phone) {\n        this.idNum = idNum;\n        this.group = group;\n        this.userAccount = userAccount;\n        this.phone = phone;\n    }\n\n    public String getIdNum() {\n        return idNum;\n    }\n\n    public void setIdNum(String idNum) {\n        this.idNum = idNum;\n    }\n\n    public String getGroup() {\n        return group;\n    }\n\n    public void setGroup(String group) {\n        this.group = group;\n    }\n\n    public String getUserAccount() {\n        return userAccount;\n    }\n\n    public void setUserAccount(String userAccount) {\n        this.userAccount = userAccount;\n    }\n\n    public String getPhone() {\n        return phone;\n    }\n\n    public void setPhone(String phone) {\n        this.phone = phone;\n    }\n\n    @Override\n    public String toString() {\n        return idNum + '☆'\n                + group + '☆'\n                + userAccount + '☆'\n                + phone + '☆';\n    }\n}\n\n```\n\n2、心跳包，顾名思义，心跳的作用，就是确定你是否还活着。 Socket 连接中，如果客户端一段时间未与服务器端通信，这时服务器端会发送一条消息给客户端，目的是了确认你是否还活着，如果客户端未响应，那么这个 Socket 链接就会关闭，所以，每隔一段时间像后台发送一个心跳包，告诉它我还是活着的，避免 Socket 链接被关闭。\n\n\n3、返回消息的处理，这里采用了广播的方式。\n\n4、别忘记加权限。\n\n```\n\npublic class PushReceiver extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        Log.i(\"PUSH\", \"接收到广播\");\n        String msg = intent.getStringExtra(\"msg\");\n        if (msg != null) {\n            String[] splitMsg = msg.split(\"☆\");\n            if (splitMsg.length < 3) {\n                return;\n            }\n            // APP 用 app 进行通知 否则用通知栏通知\n            if (\"APP\".equals(splitMsg[0])) {\n            } else {\n                int iconId = 0;\n                if (\"normal\".equals(splitMsg[1])) {\n                    iconId = R.drawable.notification;\n                } else if (\"warn\".equals(splitMsg[1])) {\n                    iconId = R.drawable.warning;\n                }\n                NotificationManager notificationManager = (NotificationManager) context.getSystemService\n                        (NOTIFICATION_SERVICE);\n\n                /**\n                 *  实例化通知栏构造器\n                 */\n\n                NotificationCompat.Builder mBuilder = new NotificationCompat.Builder(context);\n\n                /**\n                 *  设置Builder\n                 */\n                //设置标题\n                mBuilder.setContentTitle(\"通知\")\n                        //设置内容\n                        .setContentText(splitMsg[2])\n                        //设置小图标\n                        .setSmallIcon(iconId)\n                        //设置通知时间\n                        .setWhen(System.currentTimeMillis())\n                        //首次进入时显示效果\n                        .setTicker(msg)\n                        //设置通知方式，声音，震动，呼吸灯等效果，这里通知方式为声音\n                        .setDefaults(Notification.DEFAULT_SOUND);\n                //发送通知请求\n                notificationManager.notify(10, mBuilder.build());\n            }\n        }\n    }\n}\n\n\n```\n\n代码链接:\n\n pushForAndroid: [https://github.com/LakeMirror/pushForJava](https://github.com/LakeMirror/pushForJava)\n\n>> java\n\n\njava 端采用 springboot 搭建，由于公司后台是 .net 搭建, 我编写的这个后台仅做测试用， 如果有想使用的小伙伴，请进行一定的优化后再使用\n\n```\n\n@SpringBootApplication\n@RestController\npublic class App {\n    @Autowired\n    SocketService mService;\n\n    private static List<SocketBean> list = new ArrayList();\n\n    public static void main(String[] args) {\n        SpringApplication.run(App.class, args);\n        startSocketServer();\n    }\n\n    public static void startSocketServer() {\n        try {\n            ServerSocket mSocket = new ServerSocket(9998);\n            while (true) {\n                Socket socket = mSocket.accept();\n                InputStream is = socket.getInputStream();\n                byte[] bts = new byte[1024];\n                is.read(bts);\n                System.out.println(new String(bts));\n                String ids = new String(bts);\n                saveSocket(ids, socket);\n                ReceiveThread receiveThread = new ReceiveThread(socket);\n                receiveThread.start();\n//                changeState(new String(bts), \"on\", socket);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * 保存此 socket\n     *\n     * @param ids 格式 唯一标识☆分组☆用户名☆电话\n     *            如果 uid 相同或者 账户名 手机号相同 可以确认是同一个人， 只需要更新原先 bean 即可\n     */\n    private static void saveSocket(String ids, Socket socket) {\n        String[] arr = ids.split(SocketConstant.SEPARATOR);\n        if (arr.length >= 3) {\n            boolean hasRecord = false;\n            SocketBean bean = new SocketBean(arr[0], arr[2], arr[1], arr[3], socket, System.currentTimeMillis());\n            for (int position = 0; position < list.size(); position ++) {\n                SocketBean item = list.get(position);\n                if ((item.getUid().equals(arr[0]))\n                        || (item.getAccount().equals(arr[2]) && item.getPhone().equals(arr[3]))) {\n                    list.set(position, bean);\n                    hasRecord = true;\n                    return;\n                }\n            }\n            if (!hasRecord) {\n                list.add(bean);\n            }\n        }\n    }\n\n    public static void sendMessage(List<UnSendRecord> unSendRecords) {\n        List<String> deleteUid = new ArrayList<>();\n        List<SendRecord> sendRecords = new ArrayList<>();\n        try {\n            for (UnSendRecord record : unSendRecords) {\n                for (SocketBean entry : list) {\n//                    String key = entry.getUid().toString();\n                    // 设备在线\n                    if (\"on\".equals(entry.getState()) && entry.getUid().contains(record.getUid())) {\n                        Socket socket = entry.getSocket();\n                        OutputStream outputStream = socket.getOutputStream();\n                        outputStream.write(record.getMessage().getBytes());\n                        outputStream.flush();\n                        deleteUid.add(record.getNumber());\n                        sendRecords.add(new SendRecord(entry.getUid(), entry.getAccount(), record.getMessage()));\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            removeSendRecords(deleteUid);\n            doPushRecord(sendRecords);\n        }\n    }\n\t/**\n\t* 清除掉一段时间没有反应的 Socket, 减轻后台内存的负担\n\t*/\n    public static void clearSocket() {\n        Iterator<SocketBean> iterator = list.iterator();\n        while (iterator.hasNext()) {\n            SocketBean bean = iterator.next();\n            if (\"off\".equals(bean.getState()) || bean.getTimeUpdate() < System.currentTimeMillis() - ConfigConstant.TIME_JUDGE_SOCKET_DEAD) {\n                iterator.remove();\n            }\n        }\n    }\n\t/**\n\t* 推送消息\n\t*/\n    @RequestMapping(value = \"/push\", method = RequestMethod.POST)\n    public void push(@RequestBody PushModel param) {\n        formatParam(param);\n        List<UnSendRecord> offUid = new ArrayList<>();\n        String message = (param.getNotifyMethod() + SocketConstant.SEPARATOR + param.getLevel()\n                + SocketConstant.SEPARATOR + param.getMessage());\n        List<SendRecord> sendRecords = new ArrayList<>();\n        try {\n            for (SocketBean entry : list) {\n                // 如果分组信息不是 all 或者 包含要发的分组， 则不给这个人发送信息\n                if (!(\"all\".equals(entry.getGroup()) || entry.getGroup().contains(param.getGroup()))) {\n                    continue;\n                }\n                if (\"off\".equals(entry.getState())) {\n                    offUid.add(new UnSendRecord(Id.next() + \"\", entry.getUid()));\n                    continue;\n                }\n                Socket socket = entry.getSocket();\n                if (socket.isConnected()) {\n                    OutputStream outputStream = socket.getOutputStream();\n                    outputStream.write(message.getBytes());\n                    outputStream.flush();\n                    sendRecords.add(new SendRecord(entry.getUid(), entry.getAccount(), message));\n                } else {\n                    changeState(entry.getUid(), \"off\");\n                    offUid.add(new UnSendRecord(Id.next() + \"\", entry.getUid()));\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            mService.restoreOffLineUid(offUid, message);\n            doPushRecord(sendRecords);\n        }\n    }\n\n\t/**\n\t* 记录消息推送成功的日志\n\t*/\n    public static void doPushRecord(List<SendRecord> records) {\n        if (records.size() <= 0) return;\n        String statement = \"com.hugy.learn.record.pushRecord\";\n        Map params = MapUtils.asMap(\"records\", records);\n        SqlSession sqlSession = App.sqlSession();\n        sqlSession.insert(statement, params);\n        sqlSession.commit();\n        sqlSession.close();\n    }\n\t/**\n\t* 处理 push 请求传递的参数万一为空的问题\n\t*/\n    private void formatParam(PushModel param) {\n        if (\"\".equals(param.getNotifyMethod()) || param.getNotifyMethod() == null) {\n            param.setNotifyMethod(SocketConstant.METHOD_NOTIFICATION);\n        }\n        if (\"\".equals(param.getLevel()) || param.getLevel() == null) {\n            param.setLevel(SocketConstant.LEVEL_NORMAL);\n        }\n        if (param.getMessage() == null) {\n            param.setMessage(\"\");\n        }\n    }\n\t/**\n\t* 处理设备的离线请求\n\t*/\n    @RequestMapping(value = \"/offline/{uid}\", method = RequestMethod.GET)\n    public void offLine(@PathVariable String uid) {\n        changeState(uid, \"off\");\n    }\n\n    public static class ReceiveThread extends Thread {\n        public Socket mSocket;\n\n        public ReceiveThread(Socket mSocket) {\n            this.mSocket = mSocket;\n        }\n\n        @Override\n        public void run() {\n            try {\n                if (mSocket != null) {\n                    InputStream inputStream = mSocket.getInputStream();\n                    byte[] src = new byte[1024];\n                    inputStream.read(src);\n                    System.out.println(src.toString());\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\t/**\n\t* 改变 Socket 的在线状态\n\t*/\n    public static void changeState(String uid, String state) {\n        try {\n            Iterator<SocketBean> keys = list.iterator();\n            while (keys.hasNext()) {\n                SocketBean bean = keys.next();\n                String[] arr = uid.split(SocketConstant.SEPARATOR);\n                if (bean.getUid().trim().equals(arr[0].trim())) {\n                    bean.setState(state);\n                    bean.setTimeUpdate(System.currentTimeMillis());\n                    if (\"off\".equals(state)) {\n                        bean.setSocket(null);\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static SqlSession sqlSession() {\n        InputStream inputStream = App.class.\n                getClassLoader().getResourceAsStream(\"mybatis-configuration.xml\");\n\n        SqlSessionFactory sqlSessionFactory =\n                new SqlSessionFactoryBuilder().build(inputStream);\n\n        return sqlSessionFactory.openSession();\n    }\n\t/**\n\t* 发送成功后，移除数据库的需要发送记录\n\t*/\n    public static void removeSendRecords(List<String> deleteUid) {\n        if (deleteUid.size() == 0) {\n            return;\n        }\n        String statement = \"com.hugy.learn.unsend.deleteRecords\";\n        Map param = MapUtils.asMap(\"records\", deleteUid);\n        SqlSession sqlSession = App.sqlSession();\n        sqlSession.delete(statement, param);\n        sqlSession.commit(\n        sqlSession.close();\n    }\n}\n\n```\n\n定时任务\n\n```\n\n@Component\n@EnableScheduling   // 1.开启定时任务\n@EnableAsync        // 2.开启多线程\npublic class RecordTimer {\n\n\t/**\n\t* 定时重新发送消息\n\t*/\n    @Async\n    @Scheduled(fixedDelay = ConfigConstant.TIME_RESEND_FREQUENT)\n    public void reSendMessage() {\n        SqlSession sqlSession = App.sqlSession();\n        String statement = \"com.hugy.learn.unsend.selectUnSendRecord\";\n        List<UnSendRecord> unSendRecords = sqlSession.selectList(statement);\n        App.sendMessage(unSendRecords);\n    }\n\t/**\n\t* 定时清理“死掉”的 Sokcet\n\t*/\n    @Async\n    @Scheduled(fixedDelay = ConfigConstant.TIME_CLEAR_SOCKET_DEAD)\n    public void cleanSocket() {\n        App.clearSocket();\n    }\n\n}\n\n```\n\n<b>Tip:</b>\n       \n   java 端的主要作用在于维护一个保存了与服务端建立了连接的 Socket 的集合，然后在推送消息的时候从集合中取出符合要求得 Socket 进行通讯，并将无法推送的 Socket 记录保存在数据库中，以便在合适的时候推送给客户端。\n\n代码链接: \n\n  pushForJava： [https://github.com/LakeMirror/pushForJava](https://github.com/LakeMirror/pushForJava)\n\n\n> 总结\n\n  实现消息推送，客户端的主要点在于通过 Socket 实现客户端与服务端的长链接，并且通过发送心跳包的形式保持链接的“活性”，其余的如分组，消息处理等可见仁见智。\n\n  服务端的话除了建立 SocketServer 的链接外，主要就是对 SocketServer 的管理了，这部分 SocketServer 需要保存在服务器的内存中， 对服务器的性能是个不小的挑战，因此要避免同一个客户端保存多次还有长时间不动作（主要是下线后没有再次上线）的链接的清理。\n\n  最后，欢迎有问题的朋友留言讨论。\n","tags":["Socket"]}]